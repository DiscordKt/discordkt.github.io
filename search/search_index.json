{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DiscordKt is a Kotlin Discord library, built on top of Kord - a Kotlin Discord API. build.gradle.kts build.gradle pom.xml dependencies { implementation ( \"me.jakejmattson:DiscordKt:0.23.4\" ) } dependencies { implementation 'me.jakejmattson:DiscordKt:0.23.4' } <dependencies> <dependency> <groupId> me.jakejmattson </groupId> <artifactId> DiscordKt </artifactId> <version> 0.23.4 </version> </dependency> </dependencies> Syntax Samples Below are some syntax samples for the library. Startup fun main ( args : Array < String > ) { val token = \"your-bot-token\" bot ( token ) { prefix { \"+\" } } } Commands fun demo () = commands ( \"Demo\" ) { slash ( \"Hello\" , \"A 'Hello World' command.\" ) { execute { respond ( \"Hello World!\" ) } } slash ( \"Add\" , \"Add two numbers together.\" ) { execute ( IntegerArg ( \"First\" ), IntegerArg ( \"Second\" )) { val ( first , second ) = args respond ( first + second ) } } } Events fun testListeners () = listeners { on < MessageCreateEvent > { println ( message . content ) } }","title":"Home"},{"location":"#syntax-samples","text":"Below are some syntax samples for the library.","title":"Syntax Samples"},{"location":"#startup","text":"fun main ( args : Array < String > ) { val token = \"your-bot-token\" bot ( token ) { prefix { \"+\" } } }","title":"Startup"},{"location":"#commands","text":"fun demo () = commands ( \"Demo\" ) { slash ( \"Hello\" , \"A 'Hello World' command.\" ) { execute { respond ( \"Hello World!\" ) } } slash ( \"Add\" , \"Add two numbers together.\" ) { execute ( IntegerArg ( \"First\" ), IntegerArg ( \"Second\" )) { val ( first , second ) = args respond ( first + second ) } } }","title":"Commands"},{"location":"#events","text":"fun testListeners () = listeners { on < MessageCreateEvent > { println ( message . content ) } }","title":"Events"},{"location":"concepts/Data/","text":"It is often necessary to write data to persistent storage. This is commonly used for configuration files, so that will be our example. Creating @Serializable data class BotConfiguration ( var prefix : String = \"!\" ) : Data () The core of any Data is first a Kotlin data class . This is where you will add your configuration options and persistent data. To be detected correctly, you must also extend Data . DiscordKt uses Kotlin's serialization engine, which means your Data class must be annotated with @Serializable to be serialized properly. You will also need to add the kotlin serialization plugin to your build file. Registering To be loaded into DiscordKt, a Data class is passed into a loading function in the bot block bot ( token ) { val configuration = data ( \"config/config.json\" ) { Configuration () } } The data loading function takes a file path and a default value. The path is where the Data is saved/loaded on disk. When running the program for the first time, there will be nothing to load from the disk. This is where the default value comes in. On following runs, the configuration from the disk is loaded. Either way, you are guaranteed an instance of your class in the bot block. This can be used immediately to access your configuration options (or whatever data you have). Editing No matter what type of data you're storing, you will often need to make changes to these objects during runtime. This includes writing the updated version of the object to the file. DiscordKt provides a unified function for these 2 operations. configuration . edit { prefix = newPrefix } This function will edit the live configuration object, while also writing these changes to disk.","title":"Data"},{"location":"concepts/Data/#creating","text":"@Serializable data class BotConfiguration ( var prefix : String = \"!\" ) : Data () The core of any Data is first a Kotlin data class . This is where you will add your configuration options and persistent data. To be detected correctly, you must also extend Data . DiscordKt uses Kotlin's serialization engine, which means your Data class must be annotated with @Serializable to be serialized properly. You will also need to add the kotlin serialization plugin to your build file.","title":"Creating"},{"location":"concepts/Data/#registering","text":"To be loaded into DiscordKt, a Data class is passed into a loading function in the bot block bot ( token ) { val configuration = data ( \"config/config.json\" ) { Configuration () } } The data loading function takes a file path and a default value. The path is where the Data is saved/loaded on disk. When running the program for the first time, there will be nothing to load from the disk. This is where the default value comes in. On following runs, the configuration from the disk is loaded. Either way, you are guaranteed an instance of your class in the bot block. This can be used immediately to access your configuration options (or whatever data you have).","title":"Registering"},{"location":"concepts/Data/#editing","text":"No matter what type of data you're storing, you will often need to make changes to these objects during runtime. This includes writing the updated version of the object to the file. DiscordKt provides a unified function for these 2 operations. configuration . edit { prefix = newPrefix } This function will edit the live configuration object, while also writing these changes to disk.","title":"Editing"},{"location":"concepts/Listeners/","text":"To listen for Discord events, DiscordKt provides the listeners builder, where you can call on<Event> . fun demoListeners () = listeners { on < MessageCreateEvent > { println ( message . content ) } } This example listens for a single event MessageCreateEvent and prints the content of the message.","title":"Listeners"},{"location":"concepts/Permissions/","text":"When making more complicated bots, you'll want to start restricting command access. Discord slash permissions can be managed from the regular Discord UI, but it all starts from a default permission level. Permissions are defined by vanilla Discord permissions. For example, to make a command only available if the user has the \"Manage Messages\" permission, you'd define the permission object as Permissions(Permission.ManageMessages) . You can also combine permissions by specifying more than one in the constructor, for example Permissions(Permission.ManageMessages, Permission.ManageNicknames) . In this case, both the \"Manage Messages\" and the \"Manage Nicknames\" permissions are needed. Global permission level If you want, you can set a default permission level for all registered commands. This is done in the configure block. configure { defaultPermissions = Permissions ( Permission . UseApplicationCommands ) } Category permission level You can also specify a permission level for a category. To do this, you need to pass the desired permissions in the commands builder. fun adminCommands () = commands ( \"Administration\" , requiredPermissionLevel = Permissions ( Permission . Administrator )) { // ... } Command permission level Lastly, you can also set the permission level directly in the command. slash ( \"ban\" ) { requiredPermissions = Permissions ( Permission . BanMembers ) execute ( UserArg ) { args . first . asMemberOrNull ( guild . id ) ?. ban () } } The narrowest permission level will be the permission level for a command (global > category > command).","title":"Permissions"},{"location":"concepts/Permissions/#global-permission-level","text":"If you want, you can set a default permission level for all registered commands. This is done in the configure block. configure { defaultPermissions = Permissions ( Permission . UseApplicationCommands ) }","title":"Global permission level"},{"location":"concepts/Permissions/#category-permission-level","text":"You can also specify a permission level for a category. To do this, you need to pass the desired permissions in the commands builder. fun adminCommands () = commands ( \"Administration\" , requiredPermissionLevel = Permissions ( Permission . Administrator )) { // ... }","title":"Category permission level"},{"location":"concepts/Permissions/#command-permission-level","text":"Lastly, you can also set the permission level directly in the command. slash ( \"ban\" ) { requiredPermissions = Permissions ( Permission . BanMembers ) execute ( UserArg ) { args . first . asMemberOrNull ( guild . id ) ?. ban () } } The narrowest permission level will be the permission level for a command (global > category > command).","title":"Command permission level"},{"location":"concepts/Preconditions/","text":"Preconditions are a way to validate state before running a command. They apply to all commands. fun botPrecondition () = precondition { if ( author . isBot ) fail ( \"Bots cannot do this!\" ) } This code checks whether or not the user who attempted to invoke a command is a bot. If it is, the precondition will fail. All preconditions must be passed in order for a command to be run. If a precondition is failed, the String passed into the fail function will be sent as a message in the channel where the command was attempted.","title":"Preconditions"},{"location":"concepts/Services/","text":"Services contain and share your business logic. For example, we can create a MathService to apply common calculations. @Service class MathService { fun add ( a : Int , b : Int ) = a + b fun sub ( a : Int , b : Int ) = a - b fun mult ( a : Int , b : Int ) = a * b fun div ( a : Int , b : Int ) = a / b } To create a service, annotate a class with @Service . DiscordKt uses dependency injection to provide access to these objects. To use it, accept it as a parameter. This can be done anywhere you might need it, such as CommandSets, Preconditions, Listeners, and even other Services. It will automatically be given wherever it is requested. @Service class A @Service class B ( val a : A ) In this case, an instance of class A is created, then used to create an instance of class B . Each of which can be used further.","title":"Services"},{"location":"concepts/commands/Basics/","text":"To register commands using DiscordKt, create a function that calls the commands builder. This builder accepts the name of the category and can contain as many commands as you want. fun utilityCommands () = commands ( \"Utility\" ) { slash ( name = \"Ping\" , description = \"Check to see if the bot is online.\" ) { execute { respond ( \"Pong!\" ) } } } This code creates a category with the name Utility and a single command named Ping . This command is also provided a description, which will be visible whenever someone invokes help on the command, as well as written into the automatic documentation. Invoking Commands DiscordKt is fully compliant with Discord's slash commands . You can now invoke your command with /ping . This will trigger the execute function, which is the action block of all commands.","title":"Basics"},{"location":"concepts/commands/Basics/#invoking-commands","text":"DiscordKt is fully compliant with Discord's slash commands . You can now invoke your command with /ping . This will trigger the execute function, which is the action block of all commands.","title":"Invoking Commands"},{"location":"concepts/commands/Input/","text":"Accepting input into a command can be done using an Argument . An Argument's job is to transform the command input into something that you can use, or to report failure if this transformation cannot be completed successfully. Here is an example of a command that accepts some arguments. slash ( \"Plus\" , \"A simple addition command\" ) { execute ( IntegerArg ( \"First\" ), IntegerArg ( \"Second\" )) { val ( first , second ) = args respond ( \" $ first + $ second = ${ first + second } \" ) } } Arguments are accepted into the execute function of a command. This command takes in two IntegerArg arguments, but you can accept any number of arguments of any type. The action block of the execute function now has access to this input. This input is type-inferred based on the Argument, so there is no need to cast. Since the command accepts two IntegerArgs, the type for our variables ( first and second ) will be Int . Parsing and validation are handled by the Argument itself. DiscordKt will not allow any values that don't pass the checks provided by the specific Argument.","title":"Input"},{"location":"concepts/commands/Optionals/","text":"Each Argument provided to a command can be made optional with either optional or optionalNullable functions. slash ( \"DisplayText\" , \"Display some text.\" ) { execute ( AnyArg . optional ( \"Hello\" )) { val text = args . first respond ( \"Your text is: $ text \" ) } } This command accepts an optional AnyArg , meaning the command can be called with 0 or 1 arguments. The provided default value will be used if no input is provided by the user. In this case, when called with no arguments, the value of the text is \"Hello\" .","title":"Optionals"},{"location":"dsl/Conversations/","text":"In some cases, you may need to collect a lot of information from a user, which makes using commands less feasible. This is where the conversation DSL comes in. It can be used to collect information over many messages instead. Once you start a conversation, the bot will ask a series of questions to a target user and gather the responses. Here is an example conversation: fun demoConversation () = conversation ( exitString = \"exit\" ) { val name = promptMessage ( AnyArg , \"What is your name?\" ) val age = promptMessage ( IntegerArg , \"How old are you?\" ) respond ( \"Nice to meet you $ name ! $ age is a great age.\" ) } This DSL uses coroutines to prompt for values in \"real time\" as the conversation is executed. This means that you can process the input immediately after your prompt. Input To get input from a user, there are several functions you can use. Most of these blocks accept an Argument , just like a command. This is the type of data you're trying to produce. If the user's answer is not parsed successfully, the prompt will be sent again. Text prompt val age = promptMessage ( IntegerArg , \"What is your age?\" ) Validating prompt val age = promptUntil ( argumentType = IntegerArg , prompt = \"What is your age?\" , error = \"Age must be positive!\" , isValid = { it > 0 } ) Embed prompt val age = promptEmbed ( IntegerArg ) { title = \"What is your age?\" } Button prompt val response = promptButton < String > { embed { title = \"Do you like DiscordKt?\" color = Color ( 0 x00bfff ) } buttons { button ( \"Yes\" , Emojis . whiteCheckMark , \"Glad you like it\" ) button ( \"No\" , Emojis . x , \"You should let me know how to fix the lib.\" ) } } Select prompt val selections = promptSelect { this . selectionCount = 1. . 1 content { title = \"Selection\" description = \"What's your favorite letter?\" } option ( \"A\" , description = \"The first letter\" , emoji = Emojis . regionalIndicatorA . toPartialEmoji ()) option ( \"B\" , description = \"The second letter\" , emoji = Emojis . regionalIndicatorB . toPartialEmoji ()) option ( \"C\" , description = \"The third letter\" , emoji = Emojis . regionalIndicatorC . toPartialEmoji ()) } Starting a conversation Once a conversation function is written, you call it to receive your Conversation . From this, you can start it publicly (in a guild) or privately (in a DM). val result = demoConversation (). startPublicly ( discord , author , channel ) val result = demoConversation (). startPrivately ( discord , author ) Both of these functions return a ConversationResult indicating the outcome of the conversation.","title":"Conversations"},{"location":"dsl/Conversations/#input","text":"To get input from a user, there are several functions you can use. Most of these blocks accept an Argument , just like a command. This is the type of data you're trying to produce. If the user's answer is not parsed successfully, the prompt will be sent again.","title":"Input"},{"location":"dsl/Conversations/#text-prompt","text":"val age = promptMessage ( IntegerArg , \"What is your age?\" )","title":"Text prompt"},{"location":"dsl/Conversations/#validating-prompt","text":"val age = promptUntil ( argumentType = IntegerArg , prompt = \"What is your age?\" , error = \"Age must be positive!\" , isValid = { it > 0 } )","title":"Validating prompt"},{"location":"dsl/Conversations/#embed-prompt","text":"val age = promptEmbed ( IntegerArg ) { title = \"What is your age?\" }","title":"Embed prompt"},{"location":"dsl/Conversations/#button-prompt","text":"val response = promptButton < String > { embed { title = \"Do you like DiscordKt?\" color = Color ( 0 x00bfff ) } buttons { button ( \"Yes\" , Emojis . whiteCheckMark , \"Glad you like it\" ) button ( \"No\" , Emojis . x , \"You should let me know how to fix the lib.\" ) } }","title":"Button prompt"},{"location":"dsl/Conversations/#select-prompt","text":"val selections = promptSelect { this . selectionCount = 1. . 1 content { title = \"Selection\" description = \"What's your favorite letter?\" } option ( \"A\" , description = \"The first letter\" , emoji = Emojis . regionalIndicatorA . toPartialEmoji ()) option ( \"B\" , description = \"The second letter\" , emoji = Emojis . regionalIndicatorB . toPartialEmoji ()) option ( \"C\" , description = \"The third letter\" , emoji = Emojis . regionalIndicatorC . toPartialEmoji ()) }","title":"Select prompt"},{"location":"dsl/Conversations/#starting-a-conversation","text":"Once a conversation function is written, you call it to receive your Conversation . From this, you can start it publicly (in a guild) or privately (in a DM). val result = demoConversation (). startPublicly ( discord , author , channel ) val result = demoConversation (). startPrivately ( discord , author ) Both of these functions return a ConversationResult indicating the outcome of the conversation.","title":"Starting a conversation"},{"location":"dsl/Menu/","text":"Menus represent an embed message with multiple pages. respondMenu { page { title = \"Page 1\" } page { title = \"Page 2\" } buttons { button ( \"Left\" , Emojis . arrowLeft ) { previousPage () } button ( \"Right\" , Emojis . arrowRight ) { nextPage () } editButton ( \"Rainbow\" , Emojis . rainbow ) { color = genRandomColor () } } } This creates an embed message with two buttons for navigation, and one button for editing the current embed.","title":"Menu"},{"location":"extending/Arguments/","text":"To make a custom argument, we implement one of the Argument sub-interfaces. Slash commands currently accept 8 types of input; 4 primitives and 4 Discord entities. Each has a class representation: StringArgument , IntegerArgument , DoubleArgument , BooleanArgument UserArgument , RoleArgument , ChannelArgument , AttachmentArgument For this example we will extend a basic String input: open class HexColorArg ( override val name : String = \"Color\" , override val description : String = \"A hexadecimal color\" ) : StringArgument < Color > { companion object : HexColorArg () override suspend fun transform ( input : String , context : DiscordContext ): Result < Color > { if ( input . length !in 6. . 7 ) return Error ( internalLocale . invalidFormat ) val trimmedInput = input . takeLast ( 6 ). uppercase () val isValidHex = trimmedInput . all { it in '0' .. '9' || it in 'A' .. 'F' } if ( ! isValidHex ) return Error ( internalLocale . invalidFormat ) return Success ( Color ( trimmedInput . toInt ( 16 ))) } override suspend fun generateExamples ( context : DiscordContext ): List < String > = listOf ( stringify ( Color (( 0. . 255 ). random (), ( 0. . 255 ). random (), ( 0. . 255 ). random ()))) } Class Stub The class name for every argument should reflect the type of data you're trying to accept, followed by Arg . You then extend the appropriate Argument subtype, providing it the type that you want this argument to produce. Since we want our StringArgument to produce Colors from the input, we use StringArgument<Color> . Parameters The first parameter in every Argument is the name. This is what the arg will be displayed as when prompting the user for slash input. This displays the argument as \"Hex\" instead of the default \"Color\": HexColorArg(\"Hex\") The second argument is the description, which is also shown during the prompt. All args provided by DiscordKt, but it is encouraged to override this to be specific to your usage in the command. HexColorArg(\"Hex\", \"Your favorite color\") Companion Object The companion object for an Argument is just syntactic sugar when using the argument. This companion object allows you to use an Argument by name instead of having to invoke the constructor. execute(HexColorArg) instead of execute(HexColorArg()) . Examples Examples are used primarily for help menus. When help is invoked on a command, an example from each Argument is selected at random. The generateExamples function helps you generate relevant examples on the fly using the DiscordContext . Result Each Argument must return a Result that matches the type expected by the argument. So in this case, we use Result<Color> as our return type. The actual return can either be Success or Error : Error - The parsing has failed. The input args could not be converted to the required type. The String provided will be sent as a message in the channel where the command was invoked. Success - The parsing was successful. The input is consumed and the required type is returned. Transform The transform function is the logic behind every Argument. This is what converts the user input into the desired type. It accepts the following: input: String, context: DiscordContext input: T - This is the user input to the command. The type is based on the type of Argument you accept. context: DiscordContext - This is the Discord invocation context in cases where you need that to perform your transformation.","title":"Arguments"},{"location":"extending/Arguments/#class-stub","text":"The class name for every argument should reflect the type of data you're trying to accept, followed by Arg . You then extend the appropriate Argument subtype, providing it the type that you want this argument to produce. Since we want our StringArgument to produce Colors from the input, we use StringArgument<Color> .","title":"Class Stub"},{"location":"extending/Arguments/#parameters","text":"The first parameter in every Argument is the name. This is what the arg will be displayed as when prompting the user for slash input. This displays the argument as \"Hex\" instead of the default \"Color\": HexColorArg(\"Hex\") The second argument is the description, which is also shown during the prompt. All args provided by DiscordKt, but it is encouraged to override this to be specific to your usage in the command. HexColorArg(\"Hex\", \"Your favorite color\")","title":"Parameters"},{"location":"extending/Arguments/#companion-object","text":"The companion object for an Argument is just syntactic sugar when using the argument. This companion object allows you to use an Argument by name instead of having to invoke the constructor. execute(HexColorArg) instead of execute(HexColorArg()) .","title":"Companion Object"},{"location":"extending/Arguments/#examples","text":"Examples are used primarily for help menus. When help is invoked on a command, an example from each Argument is selected at random. The generateExamples function helps you generate relevant examples on the fly using the DiscordContext .","title":"Examples"},{"location":"extending/Arguments/#result","text":"Each Argument must return a Result that matches the type expected by the argument. So in this case, we use Result<Color> as our return type. The actual return can either be Success or Error : Error - The parsing has failed. The input args could not be converted to the required type. The String provided will be sent as a message in the channel where the command was invoked. Success - The parsing was successful. The input is consumed and the required type is returned.","title":"Result"},{"location":"extending/Arguments/#transform","text":"The transform function is the logic behind every Argument. This is what converts the user input into the desired type. It accepts the following: input: String, context: DiscordContext input: T - This is the user input to the command. The type is based on the type of Argument you accept. context: DiscordContext - This is the Discord invocation context in cases where you need that to perform your transformation.","title":"Transform"}]}